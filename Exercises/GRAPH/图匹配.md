
## 匈牙利算法
匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。

### 二分图最大匹配
1. 二分图      
  二分图又称为二部图，是图论中的一个特殊模型。   
  设有一无向图G，G的所有顶点可以分割为两个互不相交的子集A和B，且图中每一条边所关联的两个点分属于两个集合A,B，那么图G便是一个二分图。
2. 最大匹配
  对于一个二分图G，存在一个子集M，使得M的边集中的任意两条边都不关联同一个顶点，则M是图G的一个匹配。
    显然，边数最大的子集M即为图的最大匹配。

https://blog.csdn.net/lw277232240/article/details/72615522

```
import timeit
from collections import deque

class HungarianAlgorithm(object):
    def __init__(self, graph):
        """
        @graph:图的矩阵表示
        """
        self.graph = graph
        self.n = len(graph)

    def find(self, x):#  X 表示任何一个女生
        for i in range(self.n): # 遍历男生
            if self.graph[x][i] == 1 and not self.used[i]: # 如果这个男生没有被询问过并且两人相识
                self.used[i] = 1  # 放入交替路
                if self.match[i] == -1 or self.find(self.match[i]) == 1: # 如果当前女生是来直接找约会对象的，
                                                                          # 或者是要抛弃当前男孩去找下一个男孩的（而且找到了）。  
                    self.match[i] = x
                    self.match[x] = i
                    print(x + 1, '->', i + 1)
                    return 1            
        return 0

    def hungarian1(self):
        """递归形式
        """
        self.match = [-1] * self.n  # 记录匹配情况 
        self.used = [False] * self.n  # 记录是否访问过
        m = 0
        for i in range(self.n):
            if self.match[i] == -1:
                # 刷新used
                self.used = [False] * self.n
                print('开始匹配:', i + 1)
                m += self.find(i)
        return m

    def hungarian2(self):
        """循环形式
        """
        match = [-1] * self.n  # 记录匹配情况
        used = [-1] * self.n  # 记录是否访问过
        Q = deque()  # 设置队列
        ans = 0
        prev = [0] * self.n  # 代表上一节点
        for i in range(self.n):
            if match[i] == -1:
                Q.clear()
                Q.append(i)
                prev[i] = -1  # 设i为出发点
                flag = False  # 未找到增广路
                while len(Q) > 0 and not flag:
                    u = Q.popleft()
                    for j in range(self.n):
                        if not flag and self.graph[u][j] == 1 and used[j] != i:
                            used[j] = i
                            if match[j] != -1:
                                Q.append(match[j])
                                prev[match[j]] = u  # 记录点的顺序
                            else:
                                flag = True
                                d = u
                                e = j
                                while (d != -1):  # 将原匹配的边去掉加入原来不在匹配中的边
                                    t = match[d]
                                    match[d] = e
                                    match[e] = d
                                    d = prev[d]
                                    e = t
                                print('mathch:', match)
                                print('prev:', prev)
                                print('deque', Q)
                if match[i] != -1:  # 新增匹配边
                    ans += 1
        return ans

if __name__ == '__main__':
  graph=[(1,1,0),
       (0,1,1),
       (1,0,0)]
  h = HungarianAlgorithm(graph)
  print(h.hungarian1())

#output:
开始匹配: 1
1 -> 1
开始匹配: 2
2 -> 2
开始匹配: 3
2 -> 3
1 -> 2
3 -> 1
3
```
