# 康托展开

## 简述

康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。

## 原理

X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0! 
其中, a[i]为整数，并且0 <= a[i] <= i, 0 <= i < n, 表示当前未出现的的元素中排第几个，这就是康托展开。

## 康托展开示例

在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。

* 首位是3，则小于3的数有两个为1和2，a[5] = 2,则首位小于3的所有排列组合为 2*(5-1)!

* 第二位是4，则小于4的数有两个，为1和2，a[4] = 2注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数.2*(4-1)!

* 第三位是1，则在其之后小于1的数有0个，所以a[3]=0,排列组合为：0*(3-1)!

* 第四位是5，则在其之后小于5的数有1个，所以a[2]=1,排列组合为：1*(2-1)!

* 最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0

根据公式：    
X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0!    
= 2 * 24 + 2 * 6 + 1    
= 61 

所以比 34152 小的组合有61个，即34152是排第62。

[代码](https://github.com/Choven-Meng/Algorithms/blob/master/Cantor%20expansion/Cantor.py)

## 逆康托展开示例

一开始已经提过了，康托展开是一个全排列到一个自然数的双射，因此是可逆的。即对于上述例子，在（1，2，3，4，5）给出61可以算出起排列组合为 34152。由上述的计算过程可以容易的逆推回来，具体过程如下：

* 用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。

* 用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。

* 用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。

* 用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。

* 最后一位自然就是剩下的数2啦。

通过以上分析，所求排列组合为 34152。

[代码](https://github.com/Choven-Meng/Algorithms/tree/master/Cantor%20expansion)


# 应用示例

[例1. 字符串比大小](https://github.com/Choven-Meng/Algorithms/blob/master/Cantor%20expansion/%E5%BA%94%E7%94%A8_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E5%A4%A7%E5%B0%8F.py)
